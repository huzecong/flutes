import contextlib
import os
from typing import TextIO, IO

import tqdm

__all__ = [
    "shut_up",
    "FileProgress",
    "reverse_open",
]

from .types import PathType


@contextlib.contextmanager
def shut_up(stderr: bool = True, stdout: bool = False):
    r""" Suppress output (probably generated by external script or badly-written libraries) for stderr or stdout.
    This method can be used as a decorator, or a context manager::

        @shut_up(stderr=True)
        def verbose_func(...):
            ...

        with shut_up(stderr=True):
            ... # verbose stuff

    :param stderr: If ``True``, suppress output from stderr.
    :param stdout: If ``True``, suppress output from stdout.
    """
    # redirect output to /dev/null
    fds = ([1] if stdout else []) + ([2] if stderr else [])
    null_fds = [os.open(os.devnull, os.O_RDWR) for _ in fds]
    output_fds = [os.dup(fd) for fd in fds]
    for null_fd, fd in zip(null_fds, fds):
        os.dup2(null_fd, fd)
    yield
    # restore normal stderr
    for null_fd, output_fd, fd in zip(null_fds, output_fds, fds):
        os.dup2(output_fd, fd)
        os.close(null_fd)


class FileProgress:
    def __new__(cls, f: TextIO, *, verbose: bool = True, **kwargs):
        if not verbose:
            return f
        return super().__new__(cls)

    def __init__(self, f: TextIO, *, encoding: str = 'utf-8', **kwargs):
        self.f = f
        self.encoding = encoding
        self.file_size = os.fstat(f.fileno()).st_size
        if "verbose" in kwargs:
            del kwargs["verbose"]
        kwargs.setdefault("bar_format", "{l_bar}{bar}| [{elapsed}<{remaining}]")
        self.progress_bar = tqdm.tqdm(total=self.file_size, **kwargs)
        self.size_read = 0
        self._next_tick = 1
        self._next_size = self.file_size // 100
        self._accum_size = 0

    def __iter__(self):
        return self

    def _update(self, line: str):
        size = len(line)  # `line.decode(self.encoding)` would be more precise, but who cares?
        self._accum_size += size
        if self.size_read + self._accum_size >= self._next_size:  # do a bulk update
            self.progress_bar.update(self._accum_size)
            self.size_read += self._accum_size
            self._accum_size = 0
            while self.size_read >= self._next_size:
                self._next_tick += 1
                self._next_size = self.file_size * self._next_tick // 100

    def __next__(self) -> str:
        line = next(self.f)
        self._update(line)
        return line

    def readline(self, *args) -> str:
        line = self.f.readline(*args)
        self._update(line)
        return line

    def __enter__(self):
        self.f.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.progress_bar.close()
        self.f.__exit__(exc_type, exc_val, exc_tb)


class _ReverseReadlineFile:
    MAX_CHAR_BYTES = 4  # Maximum length of byte sequences for any character in target encoding

    @staticmethod
    def generator(fp, *, encoding='utf-8', allow_empty_lines=False, buf_size=8192):
        segment = None
        offset = 0

        fp.seek(0, os.SEEK_END)
        file_size = remaining_size = fp.tell()
        while remaining_size > 0:
            cur_buf_size = buf_size
            offset = min(file_size, offset + cur_buf_size)
            fp.seek(file_size - offset)
            buffer_bytes = fp.read(min(remaining_size, cur_buf_size))

            trials = 0
            while True:
                trials += 1
                try:
                    buffer = buffer_bytes.decode(encoding)
                    break
                except UnicodeDecodeError:
                    if trials >= _ReverseReadlineFile.MAX_CHAR_BYTES:
                        raise
                    buffer_bytes = buffer_bytes[1:]
                    cur_buf_size -= 1
                    offset -= 1
            fp.seek(file_size - offset)

            remaining_size -= cur_buf_size
            lines = buffer.split('\n')
            # the first line of the buffer is probably not a complete line so
            # we'll save it and append it to the last line of the next buffer
            # we read
            if segment is not None:
                # if the previous chunk starts right from the beginning of line
                # do not concat the segment to the last line of new chunk
                # instead, yield the segment first
                if buffer[-1] != '\n':
                    lines[-1] += segment
                else:
                    yield segment
            segment = lines[0]
            for index in range(len(lines) - 1, 0, -1):
                if allow_empty_lines or len(lines[index]):
                    yield lines[index]
        # Don't yield None if the file was empty
        if segment is not None:
            yield segment

    def __init__(self, fp: IO, gen):
        self.fp = fp
        self.gen = gen

    def __iter__(self):
        return self

    def __next__(self):
        return next(self.gen) + '\n'

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def readline(self):
        return next(self.gen)

    def close(self):
        self.fp.close()


def reverse_open(path: PathType, *, encoding: str = 'utf-8', allow_empty_lines: bool = False, buf_size: int = 8192):
    # Credits: https://stackoverflow.com/questions/2301789/read-a-file-in-reverse-order-using-python
    r"""A generator that returns the lines of a file in reverse order. Usage and syntax is the same as built-in
    method ``open``.

    :param path: Path to file.
    :param encoding: Encoding of file.
    :param allow_empty_lines: If ``False``, empty lines are skipped.
    :param buf_size: Buffer size. Most of the times you won't need to change this.
    """
    if buf_size < _ReverseReadlineFile.MAX_CHAR_BYTES:
        raise ValueError(f"`buf_size` must be at least {_ReverseReadlineFile.MAX_CHAR_BYTES}")
    fp = open(path, "rb")
    gen = _ReverseReadlineFile.generator(fp, encoding=encoding, allow_empty_lines=allow_empty_lines,
                                             buf_size=buf_size)
    return _ReverseReadlineFile(fp, gen)
